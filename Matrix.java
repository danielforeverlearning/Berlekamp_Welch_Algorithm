
package Berlekamp_Welch_Algorithm.test;

import java.util.ArrayList;
import java.util.Scanner;


public class Matrix {
    
    public Matrix()
    {
        
    }//constructor
    
    public int[][] Vandermonde(int rows, int cols, int[] vec)
    {
        /*********************************************************************
        Definition 3.1.1. Let ~α be a vector in GF(256),
        and αi be the ith element of ~α. 
        The a × b
        Vandermonde Matrix generated by ~α is defined to be
         
        
        Vandermonde(a,b (~α)) =
        
        α[0]^0         α[0]^1         α[0]^2     . . . . .  α[0]^(b-1)
        α[1]^0         α[1]^1         α[1]^2     . . . . .  α[1]^(b-1)
          .              .              .
          .              .              .
          .              .              .
          .              .              .
          .              .              .
        α[a - 1]^0     α[a - 1]^1     α[a - 1]^2 . . . . .  α[a - 1]^(b-1)
        **********************************************************************/
        Tools tool = new Tools();
        int[][] matrix = new int[rows][cols];
        for (int rr=0; rr < rows; rr++)
        {
            int num = vec[rr];
            int num_as_alpha_exp = 0;
            if (num != 0)
                num_as_alpha_exp = tool.Table_Integer_To_Exponent_Of_Alpha()[num];
            for (int cc=0; cc < cols; cc++)
            {
                if (num==0)
                {
                    int total_exp = cc;
                    if (total_exp == 0)
                        matrix[rr][cc] = 1; //0^1==1
                    else
                        matrix[rr][cc] = 0; //0^positiveint == 0
                }
                else
                {
                    int total_exp = num_as_alpha_exp * cc;
                    if (total_exp >= 256)
                        total_exp %= 255;
                    int gf256num = tool.Table_Exponent_Of_Alpha_To_Integer()[total_exp];
                    matrix[rr][cc] = gf256num;
                }
            }
        }
        return matrix;
    }//Vandermonde
    
    
    public int[][] Diag(ArrayList<Integer> vec)
    {
        int[][] matrix = new int[vec.size()][vec.size()];
        for (int rr=0; rr < vec.size(); rr++)
        {
            for (int cc=0; cc < vec.size(); cc++)
            {
                if (rr==cc)
                    matrix[rr][cc] = vec.get(rr);
                else
                    matrix[rr][cc] = 0;
            }
        }
        return matrix;
    }//Diag
    
    
    public int[][] Matrix_Multiply(int[][] A, int[][] B)
    {
        //(Arows x Acols) * (Brows x Bcols) where Acols==Brows == (Arows x Bcols)
        int Arows = A.length;
        int Brows = B.length;
        int Acols = A[0].length;
        int Bcols = B[0].length;
        
        if (Acols != Brows)
            return null;
        
        int[][] matrix = new int[Arows][Bcols];
        for (int rr=0; rr < Arows; rr++)
        {
            for (int cc=0; cc < Bcols; cc++)
            {
                int gf256num = Dot_Product(A[rr], B, cc);
                matrix[rr][cc] = gf256num;
            }
        }
        return matrix;
    }//Matrix_Multiply
    
    private int Dot_Product(int[] vec, int[][] B, int Bcol)
    {
        Tools tool = new Tools();
        int sum=0;
        for (int row=0; row < vec.length; row++)
        {
            int vecnum = vec[row];
            int bnum = B[row][Bcol];
            if (vecnum==0 || bnum==0)
                sum ^= 0;
            else
            {
                int vec_alphaexp = tool.Table_Integer_To_Exponent_Of_Alpha()[vecnum];
                int bnum_alphaexp = tool.Table_Integer_To_Exponent_Of_Alpha()[bnum];
                int totalexp = vec_alphaexp + bnum_alphaexp;
                if (totalexp >= 256)
                    totalexp %= 255;
                int gfnum = tool.Table_Exponent_Of_Alpha_To_Integer()[totalexp];
                sum ^= gfnum;
            }
        }
        return sum;
    }//Dot_Product
    
    public int[][] Matrix_Subtraction(int[][] left, int[][] rt) throws Exception
    {
        if (left.length != rt.length)
            throw new Exception("Matrix_Subtraction: left.length != rt.length");
        
        int leftcols = left[0].length;
        int rtcols = rt[0].length;
        if (leftcols != rtcols)
            throw new Exception("Matrix_Subtraction: leftcols != rtcols");
        
        Tools tool = new Tools();
        int[][] matrix = new int[left.length][leftcols];
        for (int rr=0; rr < left.length; rr++)
        {
            for (int cc=0; cc < leftcols; cc++)
            {
                int left_alphaexp = tool.Table_Integer_To_Exponent_Of_Alpha()[left[rr][cc]];
                int rt_alphaexp = tool.Table_Integer_To_Exponent_Of_Alpha()[rt[rr][cc]];
                int totalexp = left_alphaexp + rt_alphaexp;
                if (totalexp >= 256)
                    totalexp %= 255;
                int gf256num = tool.Table_Exponent_Of_Alpha_To_Integer()[totalexp];
                matrix[rr][cc] = gf256num;
            }
        }
        return matrix;
    }//Matrix_Subtraction
    
    
    public void Debug_Print(int[][] matrix) throws Exception
    {
        if (matrix==null)
            throw new Exception("Debug_Print: matrix is null");
        
        System.out.println();
        for (int rr=0; rr < matrix.length; rr++)
        {
            System.out.print("|");
            for (int cc=0; cc < matrix[0].length; cc++)
            {
                System.out.printf("%5d", matrix[rr][cc]);
            }
            System.out.println("|");
        }
        System.out.println();
    }//Debug_Print
    
    
    public int[][] Matrix_Concatenate(int[][] left, int[][] rt) throws Exception
    {
        int leftrows = left.length;
        int rtrows   = rt.length;
        if (leftrows != rtrows)
            throw new Exception("Matrix_Concatenate: leftrows != rtrows");
        
        int leftcols = left[0].length;
        int rtcols   = rt[0].length;
        int totalcols = leftcols + rtcols;
        
        int[][] matrix = new int[leftrows][totalcols];
        for (int rr=0; rr < matrix.length; rr++)
        {
            for (int cc=0; cc < matrix[0].length; cc++)
            {
                if (cc >= leftcols)
                {
                    int column = cc - leftcols;
                    matrix[rr][cc] = rt[rr][column];
                }
                else
                {
                    matrix[rr][cc] = left[rr][cc];
                }
            }
        }
        return matrix;
    }//Matrix_Concatenate
    
    
    
    public void GF256_MultiplyAndAdd(int row_mult, int mult, int row_add, int[][] matrix, int[] answer_matrix) throws Exception
    {
        Tools tool = new Tools();
        
            for (int col=0; col < matrix.length; col++)
            {
                int temp = matrix[row_mult][col];
                if (temp != 0)
                {
                    int temp_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[temp];
                    int mult_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[mult];
                    int total_exp = temp_exp + mult_exp;
                    if (total_exp >= 256)
                        total_exp %= 255;
                    int gf256num = tool.Table_Exponent_Of_Alpha_To_Integer()[total_exp];
                    //in true GF(256) additive inverse is itself which is why XOR for addition works
                    matrix[row_add][col] ^= gf256num;
                }
                //else matrix[row_add][col] remains the same
            }

            int temp = answer_matrix[row_mult];
            if (temp != 0)
            {
                int temp_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[temp];
                int mult_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[mult];
                int total_exp = temp_exp + mult_exp;
                if (total_exp >= 256)
                    total_exp %= 255;
                int gf256num = tool.Table_Exponent_Of_Alpha_To_Integer()[total_exp];
                //in true GF(256) additive inverse is itself which is why XOR for addition works
                answer_matrix[row_add] ^= gf256num;
            }
            //else answer_matrix[row_add] remains the same
        
    }//GF256_MultiplyAndAdd
    
    
    public void GF256_Multiply_Row(int row, int mult, int[][] matrix, int[] answer_matrix) throws Exception
    {
        Tools tool = new Tools();
        
            for (int col=0; col < matrix.length; col++)
            {
                int temp = matrix[row][col];
                if (temp != 0)
                {
                    int temp_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[temp];
                    int mult_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[mult];
                    int total_exp = temp_exp + mult_exp;
                    if (total_exp >= 256)
                        total_exp %= 255;
                    int gf256num = tool.Table_Exponent_Of_Alpha_To_Integer()[total_exp];
                    matrix[row][col] = gf256num;
                }
                //else matrix[row][col] remains 0
            }

            int temp = answer_matrix[row];
            if (temp != 0)
            {
                int temp_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[temp];
                int mult_exp  = tool.Table_Integer_To_Exponent_Of_Alpha()[mult];
                int total_exp = temp_exp + mult_exp;
                if (total_exp >= 256)
                    total_exp %= 255;
                int gf256num = tool.Table_Exponent_Of_Alpha_To_Integer()[total_exp];
                answer_matrix[row] = gf256num;
            }
            //else answer_matrix[row] remains 0
        
    }//GF256_Multiply_Row
    
    
    public void GF256_Add_RowA_By_RowB(int RowA, int RowB, int[][] matrix, int[] answer_matrix) throws Exception
    {
        
            for (int col=0; col < matrix.length; col++)
            {
                int Aval = matrix[RowA][col];
                int Bval = matrix[RowB][col];
                int temp = Aval ^ Bval;
                matrix[RowA][col] = temp;
            }

            int Aval = answer_matrix[RowA];
            int Bval = answer_matrix[RowB];
            int temp = Aval ^ Bval;
            answer_matrix[RowA] = temp;
        
    }//GF256_Add_RowA_By_RowB
    
    
    private boolean Check_Identity_Matrix(int[][] matrix)
    {
        for (int row=0; row < matrix.length; row++)
        {
            for (int col=0; col < matrix.length; col++)
            {
                if (matrix[row][col] != 1 && row==col)
                    return false;
                else if (matrix[row][col] != 0 && row!=col)
                    return false;
            }
        }
        return true;
    }//Check_Identity_Matrix    
    
    public boolean Robot_Solve(int[][] matrix, int[] answer_matrix)
    {   
        int row=0;
        while (true)
        {   
            boolean good = false;
            try
            {
                good = GF256_Make_Column_Good_1_And_0s(row, matrix, answer_matrix);
            }
            catch (Exception ex)
            {
                ex.printStackTrace();
                return false;
            }
            
            if (!good)
                return false;
            
            row++;
            if (row==matrix.length)
                break;
        }
        
        boolean tempbool = Check_Identity_Matrix(matrix);
        return tempbool;
    }//Robot_Solve
    
    
    private boolean GF256_Make_Column_Good_1_And_0s(int ii, int[][] matrix, int[] answer_matrix)
    {
        Tools tool = new Tools();
        boolean good = false;
        for (int row=0; row < matrix.length; row++)
        {
            if (row==ii && matrix[row][ii] == 1)
                good = true;
            else if (row!=ii && matrix[row][ii] == 0)
                good = true;
            else
            {
                good = false;
                break;
            }
        }
        
        if (good) //this column is good already
            return true;
        
        //if column all 0s, can not make it good
        int zero_count=0;
        for (int row=0; row < matrix.length; row++)
        {
            if (matrix[row][ii] == 0)
                zero_count++;
        }
        if (zero_count == matrix.length)
            return false; //can not make it good
        
        
        //make matrix[ii][ii]==1
        if (matrix[ii][ii] != 1)
        {
            if (matrix[ii][ii] != 0)
            {
                int temp_exp = tool.Table_Integer_To_Exponent_Of_Alpha()[matrix[ii][ii]];
                int mult_exp = 255 - temp_exp;
                int mult = tool.Table_Exponent_Of_Alpha_To_Integer()[mult_exp];
                try
                {
                    this.GF256_Multiply_Row(ii, mult, matrix, answer_matrix);
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                    return false;
                }
            }
            else //matrix[ii][ii] == 0
            {
                //find another row after this row==ii
                //whose matrix[row][ii] != 0 and row < matrix.length
                int row = ii;
                while (matrix[row][ii] == 0 && row < matrix.length)
                {
                    row++;
                    if (row == matrix.length)
                        return false;
                }
                
                try
                {
                    if (matrix[row][ii] == 1)
                        this.GF256_Add_RowA_By_RowB(ii, row, matrix, answer_matrix);
                    else //non-0 and non-1
                    {
                        int temp_exp = tool.Table_Integer_To_Exponent_Of_Alpha()[matrix[row][ii]];
                        int mult_exp = 255 - temp_exp;
                        int mult     = tool.Table_Exponent_Of_Alpha_To_Integer()[mult_exp];
                        this.GF256_MultiplyAndAdd(row, mult, ii, matrix, answer_matrix);
                    }//non-0 and non-1
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                    return false;
                }
            }//matrix[ii][ii] == 0
        }//make matrix[ii][ii]==1
        
        //ok matrix[ii][ii]==1
        //make cell above or below diag to 0
        for (int row=0; row < matrix.length; row++)
        {
            if (row != ii)
            {
                if (matrix[row][ii] != 0)
                {
                    //make it 0
                    //mult diag-row and then XOR because XOR is additive-inverse
                    int temp = matrix[row][ii];
                    try
                    {
                        this.GF256_MultiplyAndAdd(ii, temp, row, matrix, answer_matrix);
                    }
                    catch (Exception ex)
                    {
                        ex.printStackTrace();
                        return false;
                    }
                }
                //else already 0
            }
        }
        
        return true;
    }//GF256_Make_Column_Good_1_And_0s
    
    
    public int[][]  MoveLastColumn(int[][] matrix, int[] vec) throws Exception
    {
        int colcount = matrix[0].length;
        if (colcount != vec.length)
            throw new Exception("MoveLastColumn: colcount != vec.length");
        
        int rowcount = matrix.length;
        int lastcol  = colcount-1;
        for (int row=0; row < rowcount; row++)
            vec[row] = matrix[row][lastcol];
        
        int[][] result = new int[rowcount][lastcol];
        for (int row=0; row < rowcount; row++)
        {
            for (int col=0; col < lastcol; col++)
            {
                result[row][col] = matrix[row][col];
            }
        }
        return result;
    }//MoveLastColumn
    
}//class




